# Go
# Build your Go project.
# Add steps that test, save build artifacts, deploy, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/go

trigger:
- main

pool:
  vmImage: ubuntu-latest

variables:
  # GOBIN:  '$(GOPATH)/bin' # Go binaries path
  # GOROOT: '/usr/local/go1.11' # Go installation path
  # GOPATH: '$(system.defaultWorkingDirectory)/gopath' # Go workspace path
  # modulePath: '$(GOPATH)/src/github.com/$(build.repository.name)' # Path to the module's code
  GOOS: 'linux'
  GOARCH: 'amd64'
  imagePullSecret: 'secret'
  acrname: 'myacrchabbi'
  aksname: 'clusterchabbi'
  dockerregistry: 'akschabbi97'
  kubernetesserviceconnection: 'kubechabbi'
  azureserviceconnection: 'testapp1'
  azureresourcegroup: 'akschabbi'


steps: 
- task: GoTool@0
  inputs:
    version: '1.19'
- task: Go@0
  inputs:
    command: 'get'
    arguments: '-d'
    workingDirectory: '$(System.DefaultWorkingDirectory)'
- task: Go@0
  inputs:
    command: 'build'
    arguments: '-o $(Build.BinariesDirectory) '
    workingDirectory: '$(System.DefaultWorkingDirectory)'

- task: CopyFiles@2
  inputs:
    Contents: |
      $(System.DefaultWorkingDirectory)/manifest/deployment.yml
      $(System.DefaultWorkingDirectory)/manifest/service.yml
    TargetFolder: '$(Pipeline.Workspace)/s/manifest'
    #'$(Build.ArtifactStagingDirectory)'



- task: Docker@2
  displayName: Build Docker image
  inputs:
    containerRegistry: $(dockerregistry)
    repository: '$(acrname)/http-echo'
    command: 'build'
    Dockerfile: 'Dockerfile'
    buildContext: '$(System.DefaultWorkingDirectory)'
    tags: |
      $(Build.BuildId)
      latest

- task: Docker@2
  displayName: Push Docker image to ACR
  inputs:
    containerRegistry: $(dockerregistry)
    repository: '$(acrname)/http-echo'
    command: 'push'
    Dockerfile: 'Dockerfile'
    tags: |
      $(Build.BuildId)
      latest

- task: KubernetesManifest@0
  displayName: Create imagePullSecret
  inputs:
    action: createSecret
    secretName: $(imagePullSecret)
    dockerRegistryEndpoint: $(dockerregistry)
    kubernetesServiceConnection: $(kubernetesserviceconnection)
    namespace: 'default'

- task: PowerShell@2
  displayName: Replace RepoTag automatically
  inputs:
    targetType: 'inline'
    script: |
      $image = "$(acrname)/http-echo:$(Build.BuildId)"
      (Get-Content -Path '$(Pipeline.Workspace)/s/manifest/deployment.yml') -replace 'image: myacrchabbi.azurecr.io/http-echo:$(Build.BuildId)', ('image: ' + $image) | Set-Content -Path '$(Pipeline.Workspace)/s/manifest/deployment.yml'


- task: KubernetesManifest@0
  displayName: Deploy to Kubernetes cluster
  inputs:
    action: deploy
    kubernetesServiceConnection: '$(kubernetesserviceconnection)'
    namespace: 'default'
    manifests: |
      $(Pipeline.Workspace)/s/manifest/deployment.yml
      $(Pipeline.Workspace)/s/manifest/service.yml
    # containerRegistry: 'registryName=$(acrname);connectionString=$(acrconnectionstring)'
    # imagePullSecrets: '$(imagePullSecret)'
    imagePullSecrets: |
      $(imagePullSecret)
    containers: |
      $(acrname)/http-echo:$(tag)


- task: HelmInstaller@1
  inputs:
    helmVersionToInstall: 'latest'
    checkLatestVersion: true

- task: AzureCLI@2
  inputs:
    azureSubscription: $(azureserviceconnection)
    scriptType: 'bash'
    scriptLocation: 'inlineScript'
    inlineScript: |
      az aks get-credentials --resource-group $(azureresourcegroup) --name $(aksname)
      helm repo add haproxytech https://haproxytech.github.io/helm-charts
      helm repo update
      helm upgrade --install kubernetes-ingress haproxytech/kubernetes-ingress --create-namespace --namespace haproxy-controller --set controller.service.type=LoadBalancer
  displayName: Deploy HA-Proxy-ingress

- task: Kubernetes@1
  inputs:
    connectionType: 'Azure Resource Manager'
    azureSubscriptionEndpoint: $(azureserviceconnection)
    azureResourceGroup: $(azureresourcegroup)
    kubernetesCluster: $(aksname)
    kubernetesServiceEndpoint: $(kubernetesserviceconnection)
    command: 'get'
    arguments: 'services --namespace haproxy-controller -o jsonpath={.status.loadBalancer.ingress[0].ip} kubernetes-ingress'
    outputFormat: jsonpath='http://{.status.loadBalancer.ingress[0].ip} kubernetes-ingress' ##show the external ip in a proper way
  displayName: 'Get external IP'
  name: GetExternalIP

- task: PowerShell@2
  inputs:
    targetType: 'inline'
    script: |
      $output = jsonpath='http://{.status.loadBalancer.ingress[0].ip} kubernetes-ingress'

      # Extract the IP address and the service name from the output
      $ip_address, $service_name = $output.Split(' ')

      # Test the IP address
      try {
          $response = Invoke-WebRequest -Uri "http://$ip_address"
          if ($response.StatusCode -eq 200) {
              Write-Output "The IP address $ip_address for service $service_name is working"
          }
          else {
              Write-Output "The IP address $ip_address for service $service_name is not working"
          }
      }
      catch {
          Write-Output "Failed to connect to IP address $ip_address for service $service_name"
      }
  displayName: 'Test External IP'

# - task: Bash@3
#   inputs:
#     targetType: 'inline'
#     script: |
#       externalIP=$(echo $(GetExternalIP.outputs['value']))
#       curl -v $externalIP
#     displayName: 'Test IP Address'

# - task: Kubernetes@1
#   inputs:
#     connectionType: 'Azure Resource Manager'
#     azureSubscriptionEndpoint: $(azureserviceconnection)
#     azureResourceGroup: $(azureresourcegroup)
#     kubernetesCluster: $(aksname)
#     kubernetesServiceEndpoint: $(kubernetesserviceconnection)
#     command: 'get'
#     arguments: 'services --namespace haproxy-controller -o jsonpath={.status.loadBalancer.ingress[0].ip} kubernetes-ingress'
#     outputFormat: 'string' # Use a simpler output format
#   displayName: 'Get external IP'
#   name: GetExternalIP

# - task: Bash@3
#   inputs:
#     targetType: 'inline'
#     script: |
#        # test IP address
#   displayName: 'Test IP Address'


# - script: |
#     curl -v http://$(ExternalIP)
#   displayName: 'Test External IP with Curl'



# - script: |
#     response=$(curl -v http://20.31.56.182/)
#     echo "$response"
#   displayName: 'Curl Test'
# - script: |
#     externalIP=$(echo $(getExternalIP.outputs['stdout']) | tr -d '[:space:]')
#     response=$(curl -v http://$externalIP/)
#     echo "$response"
#   displayName: 'Curl Test'

- task: PublishBuildArtifacts@1
  inputs:
     artifactName: drop